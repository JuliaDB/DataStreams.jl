<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DataStreams.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataStreams.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Data.Source-Interface-1"><code>Data.Source</code> Interface</a></li><li><a class="toctext" href="#Data.Sink-Interface-1"><code>Data.Sink</code> Interface</a></li><li><a class="toctext" href="#Data.stream!-1"><code>Data.stream!</code></a></li><li><a class="toctext" href="#Data.Schema-1"><code>Data.Schema</code></a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/DataStreams.jl/tree/072e590363a6e230f10defda41312eb4e0d8c2e4/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DataStreams.jl-1" href="#DataStreams.jl-1">DataStreams.jl</a></h1><p>The <code>DataStreams.jl</code> package aims to define a generic and performant framework for the transfer of &quot;table-like&quot; data. (i.e. data that can, at least in some sense, be described by rows and columns).</p><p>The framework achieves this by defining interfaces (i.e. a group of methods) for <code>Data.Source</code> types and methods to describe how they &quot;provide&quot; data; as well as <code>Data.Sink</code> types and methods around how they &quot;receive&quot; data. This allows <code>Data.Source</code>s and <code>Data.Sink</code>s to implement their interfaces separately, without needing to be aware of each other. The end result is an ecosystem of packages that &quot;automatically&quot; talk with each other, with adding an additional package not requiring changes to existing packages.</p><p>Packages can have a single julia type implement both the <code>Data.Source</code> and <code>Data.Sink</code> interfaces, or two separate types can implement them separately. </p><h2><a class="nav-anchor" id="Data.Source-Interface-1" href="#Data.Source-Interface-1"><code>Data.Source</code> Interface</a></h2><p>The <code>Data.Source</code> interface includes the following definitions:</p><pre><code class="language-none">Data.schema
Data.isdone
Data.streamtype
Data.reset!
Data.streamfrom
Data.accesspattern
Data.reference</code></pre><h2><a class="nav-anchor" id="Data.Sink-Interface-1" href="#Data.Sink-Interface-1"><code>Data.Sink</code> Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStreams.Data.Sink" href="#DataStreams.Data.Sink"><code>DataStreams.Data.Sink</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Represents a type that can have data streamed to it from <code>Data.Source</code>s.</p><p>To satisfy the <code>Data.Sink</code> interface, it must provide two constructors with the following signatures:</p><pre><code class="language-none">[Sink](sch::Data.Schema, S::Type{StreamType}, append::Bool, args...; reference::Vector{UInt8}=UInt8[], kwargs...) =&gt; [Sink]
[Sink](sink, sch::Data.Schema, S::Type{StreamType}, append::Bool; reference::Vector{UInt8}=UInt8[]) =&gt; [Sink]</code></pre><p>Let&#39;s break these down, piece by piece:</p><ul><li><p><code>[Sink]</code>: this is your sink type, i.e. <code>CSV.Sink</code>, <code>DataFrame</code>, etc. You&#39;re defining a constructor for your sink type.</p></li><li><p><code>sch::Data.Schema</code>: in the streaming process, the schema of a <code>Data.Source</code> is provided to the sink in order to allow the sink to &quot;initialize&quot; properly in order to receive data according to the format in <code>sch</code>. This might mean pre-allocating space according to the # of rows/columns in the source, managing the sink&#39;s own schema to match <code>sch</code>, etc.</p></li><li><p><code>S::Type{StreamType}</code>: <code>S</code> represents the type of streaming that will occur from the <code>Data.Source</code>, either <code>Data.Field</code> or <code>Data.Column</code></p></li><li><p><code>append::Bool</code>: a boolean flag indicating whether the data should be appended to a sink&#39;s existing data store, or, if <code>false</code>, if the sink&#39;s data should be fully replaced by the incoming <code>Data.Source</code>&#39;s data</p></li><li><p><code>args...</code>: In the 1st constructor form, <code>args...</code> represents a catchall for any additional arguments your sink may need to construct. For example, <code>SQLite.jl</code> defines <code>Sink(sch, S, append, db, table_name)</code>, meaning that the <code>db</code> and <code>table_name</code> are additional required arguments in order to properly create an <code>SQLite.Sink</code>.</p></li><li><p><code>reference::Vector{UInt8}</code>: if your sink defined <code>Data.weakrefstrings(sink::MySink) = true</code>, then it also needs to be able to accept the <code>reference</code> keyword argument, where a source&#39;s memory block will be passed, to be held onto appropriately by the sink when streaming WeakRefStrings. If a sink does not support streaming WeakRefStrings (the default), the sink constructor doesn&#39;t need to support any keyword arguments.</p></li><li><p><code>kwargs...</code>: Similar to <code>args...</code>, <code>kwargs...</code> is a catchall for any additional keyword arguments you&#39;d like to expose for your sink constructor, typically matching supported keyword arguments that are provided through the normal sink constructor</p></li><li><p><code>sink</code>: in the 2nd form, an already-constructed sink is passed in as the 1st argument. This allows efficient sink re-use. This constructor needs to ensure the existing sink is modified (enlarged, shrunk, schema changes, etc) to be ready to accept the incoming source data as described by <code>sch</code>.</p></li></ul><p>Now let&#39;s look at an example implementation from CSV.jl:</p><pre><code class="language-julia">function CSV.Sink(fullpath::AbstractString; append::Bool=false, headers::Bool=true, colnames::Vector{String}=String[], kwargs...)
    io = IOBuffer()
    options = CSV.Options(kwargs...)
    !append &amp;&amp; header &amp;&amp; !isempty(colnames) &amp;&amp; writeheaders(io, colnames, options)
    return CSV.Sink(options, io, fullpath, position(io), !append &amp;&amp; header &amp;&amp; !isempty(colnames), colnames, length(colnames), append)
end

function CSV.Sink(sch::Data.Schema, T, append, file::AbstractString; reference::Vector{UInt8}=UInt8[], kwargs...)
    sink = CSV.Sink(file; append=append, colnames=Data.header(sch), kwargs...)
    return sink
end

function CSV.Sink(sink, sch::Data.Schema, T, append; reference::Vector{UInt8}=UInt8[])
    sink.append = append
    sink.cols = size(sch, 2)
    !sink.header &amp;&amp; !append &amp;&amp; writeheaders(sink.io, Data.header(sch), sink.options, sink.quotefields)
    return sink
end</code></pre><p>In this case, CSV.jl defined an initial constructor that just takes the filename with a few keyword arguments. The two required Data.Sink constructors are then defined. The first constructs a new Sink, requiring a <code>file::AbstractString</code> argument. We also see that <code>CSV.Sink</code> supports WeakRefString streaming by accepting a <code>reference</code> keyword argument (which is trivially implemented for CSV, since all data is simply written out to disk as text).</p><p>For the 2nd (last) constructor in the definitions above, we see the case where an existing <code>sink</code> is passed to <code>CSV.Sink</code>. The sink updates a few of its fields (<code>sink.append = append</code>), and some logic is computed to determine if the column headers should be written.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataStreams.jl/tree/072e590363a6e230f10defda41312eb4e0d8c2e4/src/DataStreams.jl#L236-L287">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStreams.Data.streamtypes" href="#DataStreams.Data.streamtypes"><code>DataStreams.Data.streamtypes</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>Data.streamtypes(::Type{[Sink]})</code> =&gt; Vector{StreamType}</p><p>Returns a vector of <code>Data.StreamType</code>s that the sink is able to receive; the order of elements indicates the sink&#39;s streaming preference</p><p>For example, if my sink only supports <code>Data.Field</code> streaming, I would simply define:</p><pre><code class="language-julia">Data.streamtypes(::Type{MyPkg.Sink}) = [Data.Field]</code></pre><p>If, on the other hand, my sink also supported <code>Data.Column</code> streaming, and <code>Data.Column</code> streaming happend to be more efficient, I could define:</p><pre><code class="language-julia">Data.streamtypes(::Type{MyPkg.Sink}) = [Data.Column, Data.Field] # put Data.Column first to indicate preference</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataStreams.jl/tree/072e590363a6e230f10defda41312eb4e0d8c2e4/src/DataStreams.jl#L290-L304">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStreams.Data.streamto!" href="#DataStreams.Data.streamto!"><code>DataStreams.Data.streamto!</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Data.streamto!(sink, S::Type{StreamType}, val, row, col) Data.streamto!(sink, S::Type{StreamType}, val, row, col, knownrows)</p><p>Streams data to a sink. <code>S</code> is the type of streaming (<code>Data.Field</code> or <code>Data.Column</code>). <code>val</code> is the value (single field or column) to be streamed to the sink. <code>row</code> and <code>col</code> indicate where the data should be streamed/stored.</p><p>A sink may optionally define the method that also accepts the <code>knownrows</code> argument, which will be <code>true</code> or <code>false</code>, indicating whether the source streaming has a known # of rows or not. This can be useful for sinks that may know how to pre-allocate space in the cases where the source can tell the # of rows, or in the case of unknown # of rows, may need to stream the data in differently.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataStreams.jl/tree/072e590363a6e230f10defda41312eb4e0d8c2e4/src/DataStreams.jl#L307-L318">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStreams.Data.cleanup!" href="#DataStreams.Data.cleanup!"><code>DataStreams.Data.cleanup!</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Data.cleanup!(sink)</p><p>Sometimes errors occur during the streaming of data from source to sink. Some sinks may be left in an undesired state if an error were to occur mid-streaming. <code>Data.cleanup!</code> allows a sink to &quot;clean up&quot; any necessary resources in the case of a streaming error. <code>SQLite.jl</code>, for example, defines:</p><pre><code class="language-julia">function Data.cleanup!(sink::SQLite.Sink)
    rollback(sink.db, sink.transaction)
    return
end</code></pre><p>Since a database transaction is initiated at the start of streaming, it must be rolled back in the case of streaming error.</p><p>The default definition is: <code>Data.cleanup!(sink) = nothing</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataStreams.jl/tree/072e590363a6e230f10defda41312eb4e0d8c2e4/src/DataStreams.jl#L324-L339">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStreams.Data.close!" href="#DataStreams.Data.close!"><code>DataStreams.Data.close!</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Data.close!(sink) =&gt; sink</p><p>A function to &quot;close&quot; a sink to streaming. Some sinks require a definitive time where data can be &quot;committed&quot;, <code>Data.close!</code> allows a sink to perform any necessary resource management or commits to ensure all data that has been streamed is stored appropriately. For example, the <code>SQLite</code> package defines:</p><pre><code class="language-julia">function Data.close!(sink::SQLite.Sink)
    commit(sink.db, sink.transaction)
    return sink
end</code></pre><p>Which commits a database transaction that was started when the sink was initially &quot;opened&quot;.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataStreams.jl/tree/072e590363a6e230f10defda41312eb4e0d8c2e4/src/DataStreams.jl#L342-L355">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStreams.Data.weakrefstrings" href="#DataStreams.Data.weakrefstrings"><code>DataStreams.Data.weakrefstrings</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Data.weakrefstrings(sink) =&gt; Bool</p><p>If a sink is able to appropriately handle <code>WeakRefString</code> objects, it can define:</p><pre><code class="language-julia">Data.weakrefstrings(::Type{[Sink]}) = true</code></pre><p>to indicate that a source may stream those kinds of values to it. By default, sinks do not support WeakRefString streaming. Supporting WeakRefStrings corresponds to accepting the <code>reference</code> keyword argument in the required sink constructor method, see <code>?Data.Sink</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataStreams.jl/tree/072e590363a6e230f10defda41312eb4e0d8c2e4/src/DataStreams.jl#L362-L372">source</a><br/></section><h2><a class="nav-anchor" id="Data.stream!-1" href="#Data.stream!-1"><code>Data.stream!</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStreams.Data.stream!" href="#DataStreams.Data.stream!"><code>DataStreams.Data.stream!</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Data.stream!(source, sink; append::Bool=false, transforms=Dict()) Data.stream!(source, ::Type{Sink}, args...; append::Bool=false, transforms=Dict(), kwargs...)</p><p>Stream data from source to sink. The 1st definition assumes already constructed source &amp; sink and takes two optional keyword arguments:</p><ul><li><p><code>append::Bool=false</code>: whether the data from <code>source</code> should be appended to <code>sink</code></p></li><li><p><code>transforms::Dict</code>: A dict with mappings between column # or name (Int or String) to a &quot;transform&quot; function. For <code>Data.Field</code> streaming, the transform function should be of the form <code>f(x::T) =&gt; y::S</code>, i.e. takes a single input of type <code>T</code> and returns a single value of type <code>S</code>. For <code>Data.Column</code> streaming, it should be of the form <code>f(x::AbstractVector{T}) =&gt; y::AbstractVector{S}</code>, i.e. take an AbstractVector with eltype <code>T</code> and return another AbstractVector with eltype <code>S</code>.</p></li></ul><p>For the 2nd definition, the Sink type itself is passed as the 2nd argument (<code>::Type{Sink}</code>) and is constructed &quot;on-the-fly&quot;, being passed <code>args...</code> and <code>kwargs...</code> like <code>Sink(args...; kwargs...)</code>.</p><p>While users are free to call <code>Data.stream!</code> themselves, oftentimes, packages want to provide even higher-level convenience functions.</p><p>An example of of these higher-level convenience functions are from CSV.jl:</p><pre><code class="language-julia">function CSV.read(fullpath::Union{AbstractString,IO}, sink::Type=DataFrame, args...; append::Bool=false, transforms::Dict=Dict{Int,Function}(), kwargs...)
    source = CSV.Source(fullpath; kwargs...)
    sink = Data.stream!(source, sink, args...; append=append, transforms=transforms, kwargs...)
    return Data.close!(sink)
end

function CSV.read{T}(fullpath::Union{AbstractString,IO}, sink::T; append::Bool=false, transforms::Dict=Dict{Int,Function}(), kwargs...)
    source = CSV.Source(fullpath; kwargs...)
    sink = Data.stream!(source, sink; append=append, transforms=transforms)
    return Data.close!(sink)
end</code></pre><p>In this example, CSV.jl defines it&#39;s own high-level function for reading from a <code>CSV.Source</code>. In these examples, a <code>CSV.Source</code> is constructed using the <code>fullpath</code> argument, along w/ any extra <code>kwargs...</code>. The sink can be provided as a type with <code>args...</code> and <code>kwargs...</code> that will be passed to its DataStreams constructor, like <code>Sink(sch, streamtype, append, args...; kwargs...)</code>; otherwise, an already-constructed Sink can be provided directly (2nd example).</p><p>Once the <code>source</code> is constructed, the data is streamed via the call to <code>Data.stream(source, sink; append=append, transforms=transforms)</code>, with the sink being returned.</p><p>And finally, to &quot;finish&quot; the streaming process, <code>Data.close!(sink)</code> is closed, which returns the finalized sink. Note that <code>Data.stream!(source, sink)</code> could be called multiple times with different sources and the same sink, most likely with <code>append=true</code> being passed, to enable the accumulation of several sources into a single sink. A single <code>Data.close!(sink)</code> method should be called to officially close or commit the final sink.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataStreams.jl/tree/072e590363a6e230f10defda41312eb4e0d8c2e4/src/DataStreams.jl#L377-L413">source</a><br/></section><h2><a class="nav-anchor" id="Data.Schema-1" href="#Data.Schema-1"><code>Data.Schema</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStreams.Data.Schema" href="#DataStreams.Data.Schema"><code>DataStreams.Data.Schema</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A <code>Data.Schema</code> describes a tabular dataset, i.e. a set of named, typed columns with records as rows</p><p><code>Data.Schema</code> allow <code>Data.Source</code> and <code>Data.Sink</code> to talk to each other and prepare to provide/receive data through streaming. <code>Data.Schema</code> provides the following accessible properties:</p><ul><li><p><code>Data.header(schema)</code> to return the header/column names in a <code>Data.Schema</code></p></li><li><p><code>Data.types(schema)</code> to return the column types in a <code>Data.Schema</code>; <code>Nullable{T}</code> indicates columns that may contain missing data (null values)</p></li><li><p><code>Data.size(schema)</code> to return the (# of rows, # of columns) in a <code>Data.Schema</code>; note that # of rows may be <code>null</code>, meaning unknown</p></li></ul><p><code>Data.Schema</code> has the following constructors:</p><ul><li><p><code>Data.Schema()</code>: create an &quot;emtpy&quot; schema with no rows, no columns, and no column names</p></li><li><p><code>Data.Schema(types[, header, rows, meta::Dict])</code>: column element types are provided as a tuple or vector; column names provided as an iterable; # of rows can be an Int or <code>null</code> to indicate unknown # of rows</p></li></ul><p><code>Data.Schema</code> are indexable via column names to get the number of that column in the <code>Data.Schema</code></p><pre><code class="language-julia">julia&gt; sch = Data.Schema([&quot;column1&quot;], [Int], 10)
Data.Schema:
rows: 10	cols: 1
Columns:
 &quot;column1&quot;  Int64

julia&gt; sch[&quot;column1&quot;]
1</code></pre><p><strong>Developer note</strong>: the full type definition is <code>Data.Schema{R, T}</code> where the <code>R</code> type parameter will be <code>true</code> or <code>false</code>, indicating whether the # of rows are known (i.e not <code>null</code>), respectively. The <code>T</code> type parameter is a <code>Tuple{A, B, ...}</code> representing the column element types in the <code>Data.Schema</code>. Both of these type parameters provide valuable information that may be useful when constructing <code>Sink</code>s or streaming data.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataStreams.jl/tree/072e590363a6e230f10defda41312eb4e0d8c2e4/src/DataStreams.jl#L15-L46">source</a><br/></section><p>The reference DataStreams interface implementation lives in the <a href="https://github.com/JuliaData/DataStreams.jl/blob/master/src/DataStreams.jl#L370">DataStreams.jl package itself</a>, implemented for a NamedTuple with AbstractVector elements.</p><p>For examples of additional interface implementations, see some of the packages below:</p><p><code>Data.Source</code> implementations:</p><ul><li><p><a href="https://github.com/JuliaData/CSV.jl/blob/master/src/Source.jl"><code>CSV.Source</code></a></p></li><li><p><a href="https://github.com/JuliaDB/SQLite.jl/blob/master/src/Source.jl"><code>SQLite.Source</code></a></p></li><li><p><a href="https://github.com/JuliaDB/ODBC.jl/blob/master/src/Source.jl"><code>ODBC.Source</code></a></p></li></ul><p><code>Data.Sink</code> implementations:</p><ul><li><p><a href="https://github.com/JuliaData/CSV.jl/blob/master/src/Sink.jl"><code>CSV.Sink</code></a></p></li><li><p><a href="https://github.com/JuliaDB/SQLite.jl/blob/master/src/Sink.jl"><code>SQLite.Sink</code></a></p></li><li><p><a href="https://github.com/JuliaDB/ODBC.jl/blob/master/src/Sink.jl"><code>ODBC.Sink</code></a></p></li></ul><footer><hr/></footer></article></body></html>
